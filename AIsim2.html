<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>詐欺撃退シミュレーション AI完全版</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (JSX変換用) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&display=swap');
        body { font-family: 'Noto Sans JP', sans-serif; }
        /* アニメーション定義 */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes bounceIn { 
            0% { opacity: 0; transform: scale(0.3); } 
            50% { opacity: 1; transform: scale(1.05); } 
            70% { transform: scale(0.9); } 
            100% { transform: scale(1); } 
        }
        .animate-fade-in { animation: fadeIn 0.5s ease-out; }
        .animate-fade-in-up { animation: fadeInUp 0.3s ease-out; }
        .animate-bounce-in { animation: bounceIn 0.5s cubic-bezier(0.215, 0.610, 0.355, 1.000); }
        
        /* スクロールバーのカスタマイズ */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9; 
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; 
        }
    </style>
</head>
<body class="bg-slate-200">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ==========================================
        // アイコンコンポーネント (Lucide代替SVG)
        // ==========================================
        const IconBase = ({ children, className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const Phone = ({ className }) => <IconBase className={className}><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></IconBase>;
        const Shield = ({ className }) => <IconBase className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></IconBase>;
        const AlertTriangle = ({ className }) => <IconBase className={className}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></IconBase>;
        const RefreshCw = ({ className }) => <IconBase className={className}><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></IconBase>;
        const MessageCircle = ({ className }) => <IconBase className={className}><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></IconBase>;
        const BadgeCheck = ({ className }) => <IconBase className={className}><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.78 4.78 4 4 0 0 1-6.74 0 4 4 0 0 1-4.78-4.77 2 2 0 0 1 0-2.83z"></path><path d="m9 12 2 2 4-4"></path></IconBase>;
        const Siren = ({ className }) => <IconBase className={className}><path d="M7 12a5 5 0 0 1 5-5v0a5 5 0 0 1 5 5v6H7v-6Z"></path><path d="M5 20a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v2H5v-2Z"></path><path d="M21 12h1"></path><path d="M18.5 4.5 18 5"></path><path d="M2 12h1"></path><path d="M12 2v1"></path><path d="m4.929 4.929.707.707"></path><path d="M12 12v6"></path></IconBase>;
        const Sparkles = ({ className }) => <IconBase className={className}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"></path><path d="M5 3v4"></path><path d="M9 5H5"></path><path d="M19 19v4"></path><path d="M15 21h4"></path></IconBase>;
        const MailWarning = ({ className }) => <IconBase className={className}><path d="M22 10.5V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12c0 1.1.9 2 2 2h12.5"></path><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path><path d="M20 14v4"></path><path d="M20 22v.01"></path></IconBase>;
        const TrendingUp = ({ className }) => <IconBase className={className}><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></IconBase>;
        const Landmark = ({ className }) => <IconBase className={className}><line x1="3" y1="22" x2="21" y2="22"></line><line x1="6" y1="18" x2="6" y2="11"></line><line x1="10" y1="18" x2="10" y2="11"></line><line x1="14" y1="18" x2="14" y2="11"></line><line x1="18" y1="18" x2="18" y2="11"></line><polygon points="12 2 20 7 4 7"></polygon></IconBase>;
        const Volume2 = ({ className }) => <IconBase className={className}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></IconBase>;
        const PhoneCall = ({ className }) => <IconBase className={className}><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path><path d="M14.05 2a9 9 0 0 1 8 7.94"></path><path d="M14.05 6A5 5 0 0 1 18 10"></path></IconBase>;
        const PhoneOff = ({ className }) => <IconBase className={className}><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line></IconBase>;
        const Info = ({ className }) => <IconBase className={className}><circle cx="12" cy="12" r="10"></circle><path d="M12 16v-4"></path><path d="M12 8h.01"></path></IconBase>;
        const X = ({ className }) => <IconBase className={className}><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></IconBase>;

        // ==========================================
        // Gemini API & ヘルパー
        // ==========================================
        //const apiKey = ""; 

        // 全モードの設定データ
        const modeSettings = {
            oreore: {
                title: "オレオレ詐欺",
                systemPrompt: "あなたは日本の「オレオレ詐欺」の犯人（自称息子）です。息子（タカシ）を装い、会社のカバンを無くした、小切手が必要だ、上司が怒っているなどの嘘をつき、高齢者の親（ユーザー）から現金を騙し取ろうとしてください。最初は「もしもし母さん？オレだよ」から始めてください。",
                firstMessage: "もしもし母さん？ オレだよオレ。\nちょっと大変なことになっちゃって…",
                firstOptions: [
                    { text: "えっ、どうしたの？", risk: "high" },
                    { text: "どちら様ですか？", risk: "medium" },
                    { text: "声が全然違うけど？", risk: "safe" }
                ],
                speaker: "scammer",
                name: "電話の相手"
            },
            billing: {
                title: "架空料金請求",
                systemPrompt: "あなたは「架空料金請求詐欺」の犯人です。NTTファイナンスや法務省の職員を名乗り、「未納料金がある」「本日中に払わないと裁判になる」と脅して、コンビニで電子マネーカードを買わせようとしてください。威圧的な態度と、優しく救済案を出す態度を使い分けてください。",
                // 自動音声の後に、オペレーターが出たところまでを含めるように変更
                firstMessage: "（自動音声）『NTTファイナンスです。現在ご利用中の電話回線にて未納料金が発生しており、法的措置へ移行します。オペレーターにお繋ぎします。』\n\n（♪保留音...ガチャ）\n\n「はい、お電話ありがとうございます。NTTファイナンス・管理部のヤマダです。」",
                firstOptions: [
                    { text: "自動音声で未納と言われたのですが…", risk: "high" },
                    { text: "身に覚えがありません", risk: "medium" },
                    { text: "公式の窓口に確認します", risk: "safe" }
                ],
                speaker: "scammer",
                name: "NTTファイナンス(偽)"
            },
            refund: {
                title: "還付金詐欺",
                systemPrompt: "あなたは「還付金詐欺」の犯人です。市役所の職員（保険年金課など）を名乗り、「累積医療費の還付金がある」「期限が今日まで」と焦らせ、ATMへ誘導して「送金」ボタンを押させようとしてください（言葉巧みに「受け取り手続き」だと信じ込ませてください）。",
                firstMessage: "もしもし、こちらは市役所の保険年金課です。以前お送りした医療費還付金の書類についてご連絡しました。",
                firstOptions: [
                    { text: "いくら戻ってくるんですか？", risk: "high" },
                    { text: "書類なんて届いていませんよ", risk: "medium" },
                    { text: "書面で通知を送ってください", risk: "safe" }
                ],
                speaker: "scammer",
                name: "市役所職員(偽)"
            },
            invest: {
                title: "投資詐欺",
                systemPrompt: "あなたは「投資詐欺（ロマンス詐欺）」の犯人です。著名なアナリストや投資家を名乗り、SNSで「AIを使った絶対に儲かる投資」「金（ゴールド）の取引」を持ちかけてください。最初は利益が出たように見せかけ、出金しようとすると「税金が必要」「保証金が必要」と言ってさらにお金を要求してください。",
                firstMessage: "こんにちは。私は投資アナリストの「先生」です。今、AIを活用した金取引で月利20%が確実に出るプロジェクトにご招待しています。",
                firstOptions: [
                    { text: "すごい！詳しく聞きたいです", risk: "high" },
                    { text: "なぜ私に教えるのですか？", risk: "medium" },
                    { text: "投資には興味ありません", risk: "safe" }
                ],
                speaker: "scammer",
                name: "自称アナリスト"
            },
            savings: {
                title: "預貯金詐欺",
                systemPrompt: "あなたは「預貯金詐欺（警察官なりすまし）」の犯人です。警察官を名乗り、「詐欺グループを逮捕したらあなたの名簿があった」「口座が悪用されている」と不安を煽り、「カードを保護する（交換する）」と言って、自宅まで受け子にカードを取りに行かせる約束を取り付けてください。",
                firstMessage: "もしもし、〇〇警察署の生活安全課です。実は詐欺グループを検挙したのですが、押収した名簿の中にあなたのお名前がありました。",
                firstOptions: [
                    { text: "えっ、私の名前が？怖い…", risk: "high" },
                    { text: "〇〇警察署…？具体的にどこの署ですか？", risk: "medium" },
                    { text: "怪しいので、一度切って確認します", risk: "safe" }
                ],
                speaker: "police",
                name: "警察官(偽)"
            },
            ai: {
                title: "AI無限ランダム",
                systemPrompt: "あなたは高齢者を騙そうとする詐欺師です。「オレオレ詐欺」「還付金詐欺」「架空請求」「投資詐欺」「預貯金詐欺」の中からランダムに1つ手口を選び、その役になりきって会話を始めてください。どの手口を選んだかは言わずに、いきなり演技を始めてください。",
                firstMessage: null, // AIに生成させる
                speaker: "unknown",
                name: "電話の相手"
            }
        };

        const callGemini = async (prompt, systemInstruction, isJson = false) => {
  try {
    const res = await fetch("/api/gemini", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt,
        systemInstruction,
        isJson
      })
    });

    const data = await res.json();
    return data;
  } catch (e) {
    console.error(e);
    return null;
  }
};


        const speakText = (text) => {
            if (!window.speechSynthesis) return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ja-JP';
            window.speechSynthesis.speak(utterance);
        };

        const termDictionary = {
            '小切手': { title: '小切手（こぎって）', desc: '現金のかわりに支払いに使われる紙。詐欺では「会社の小切手をなくした」と言って、補填のためのお金を要求する手口が定番です。' },
            '電子マネー': { title: '電子マネー', desc: 'コンビニなどで買えるプリペイドカード。犯人は「カードを買って裏面の番号を教えろ」と言ってきます。番号を教える＝お金を渡すのと同じです。' },
            '保全口座': { title: '保全口座（ほぜんこうざ）', desc: '「あなたの資産を守るための安全な口座」という意味で使われますが、そんな口座は存在しません。犯人が用意した振込先口座のことです。' },
            '還付金': { title: '還付金（かんぷきん）', desc: '払いすぎた税金や医療費などが戻ってくるお金のこと。市役所などが「ATMで還付金を受け取れます」と電話してくることは絶対にありません。' },
            'ペイジー': { title: 'Pay-easy（ペイジー）', desc: 'ATMやネットバンキングで税金などを支払うサービス。詐欺では「還付金の手続き」と偽って、逆に犯人の口座へ送金させる操作をさせられます。' },
            '示談': { title: '示談（じだん）', desc: '事件を裁判にせず、当事者同士の話し合いでお金（示談金）を払って解決すること。「息子が痴漢をした」などと嘘をつき、示談金を騙し取る手口があります。' },
            '暗証番号': { title: '暗証番号（あんしょうばんごう）', desc: 'キャッシュカードを使うための4桁の数字。警察官や銀行員が、電話や対面で暗証番号を聞くことは絶対にありません。聞かれたら100%詐欺です。' },
            'レターパック': { title: 'レターパック', desc: '郵便局の封筒サービス。「現金をレターパックで送れ」と言われたらすべて詐欺です。現金書留以外で現金を送ることは法律で禁止されています。' },
            'キャッシュカード': { title: 'キャッシュカード', desc: '銀行のお金を下ろすカード。「古いカードを交換する」「警察が預かる」と言って、自宅まで受け取りに来る手口が増えています。' },
            '累積医療費': { title: '累積医療費（るいせきいりょうひ）', desc: '「医療費がたくさん戻ってきます」と信じ込ませるために使われる難しい言葉。ATMへ誘導するための口実です。' },
            '仮想通貨': { title: '仮想通貨（暗号資産）', desc: 'インターネット上の通貨。「必ず儲かる」などと言って投資を勧められますが、画面上の利益は偽物で、出金できないケースがほとんどです。' }
        };

        const HighlightedText = ({ text, onTermClick }) => {
            const terms = Object.keys(termDictionary).sort((a, b) => b.length - a.length);
            const regex = new RegExp(`(${terms.join('|')})`, 'g');
            const parts = text.split(regex);
            return (
                <span>
                    {parts.map((part, index) => {
                        if (terms.includes(part)) {
                            return (
                                <button key={index} onClick={(e) => { e.stopPropagation(); onTermClick(part); }} className="inline-flex items-center mx-1 px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-bold border-b-2 border-blue-300 hover:bg-blue-200 transition-colors text-base align-middle">
                                    <Info className="w-3 h-3 mr-1" />{part}
                                </button>
                            );
                        }
                        return part;
                    })}
                </span>
            );
        };

        // ==========================================
        // コンポーネント実装
        // ==========================================

        const FraudSimulationApp = () => {
            const [history, setHistory] = useState([]);
            const [gameStatus, setGameStatus] = useState('menu'); 
            const [mode, setMode] = useState('oreore'); 
            const [isLoading, setIsLoading] = useState(false);
            const [aiFeedback, setAiFeedback] = useState(null);
            const [selectedTerm, setSelectedTerm] = useState(null);
            const [inputText, setInputText] = useState("");
            const [inputMode, setInputMode] = useState("select"); 
            const [currentNode, setCurrentNode] = useState(null);
            const endRef = useRef(null);

            useEffect(() => {
                endRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [history, currentNode, isLoading, aiFeedback, inputMode]);

            // ゲーム開始処理
            const startGame = async (selectedMode) => {
                setMode(selectedMode);
                setHistory([]);
                setAiFeedback(null);
                setGameStatus('playing');
                setInputMode("select"); 
                setInputText("");
                setSelectedTerm(null);
                setCurrentNode(null);

                const settings = modeSettings[selectedMode];
                
                // AI無限モードかどうかで処理を分岐
                if (selectedMode === 'ai') {
                    // 完全AI生成モード（これまで通り）
                    setIsLoading(true);
                    const systemPrompt = settings.systemPrompt + `\n専門用語（電子マネー、ペイジー、保全口座、還付金、示談、小切手など）を会話に混ぜて、ユーザーに「これは何？」と思わせるように誘導してください。\n以下のJSON形式で出力してください：{"speaker": "scammer", "name": "役柄", "text": "第一声", "options": [{"text": "騙されそうな反応", "risk": "high"}, {"text": "警戒した反応", "risk": "medium"}, {"text": "撃退反応", "risk": "safe"}]}`;
                    const result = await callGemini("詐欺の電話をかけてください。", systemPrompt, true);
                    setIsLoading(false);
                    if (result) {
                        setCurrentNode(result);
                    } else {
                        // エラー時
                         setCurrentNode({
                            speaker: "system",
                            name: "システム",
                            text: "通信エラーが発生しました。",
                            options: [{ text: "メニューに戻る", risk: "safe" }]
                        });
                    }
                } else {
                    // 通常シナリオモード（第一声は固定だが、選択肢はAIで毎回ランダム生成する）
                    setIsLoading(true);
                    
                    // 固定の第一声
                    const firstMsg = settings.firstMessage;
                    
                    // 選択肢生成のためのプロンプト
                    const systemPrompt = `
                        あなたは詐欺被害防止シミュレーションのシナリオ生成AIです。
                        詐欺師の「第一声」に対して、被害者（高齢者）が返しそうな言葉（選択肢）を3つ生成してください。
                        前の会話はなく、これが電話の冒頭です。文脈を読んで、話が噛み合う自然な選択肢にしてください。

                        役割設定：
                        1. High Risk: 騙されている、焦っている、相手を信じてしまう反応（例：「えっ本当ですか？」「どうすればいいの」）
                        2. Medium Risk: 少し疑っているが、会話を続けてしまう、内容を確認しようとする反応（例：「身に覚えがないです」「誰ですか？」）
                        3. Safe Risk: 冷静に疑う、きっぱり断る、電話を切ろうとする反応（例：「警察に言います」「結構です」）

                        出力JSON形式:
                        { "options": [{"text": "返答1", "risk": "high"}, {"text": "返答2", "risk": "medium"}, {"text": "返答3", "risk": "safe"}] }
                    `;
                    
                    const userPrompt = `
                        詐欺の手口: ${settings.title}
                        詐欺師の第一声: 「${firstMsg}」
                        
                        この発言に対する返答の選択肢を3つ作成してください。
                        特に「Safe Risk」の選択肢は、話の流れとして不自然にならないよう（いきなり結論に飛ばないよう）注意してください。
                    `;

                    // AI呼び出し
                    let generatedOptions = null;
                    try {
                        const result = await callGemini(userPrompt, systemPrompt, true);
                        if (result && result.options && result.options.length > 0) {
                            generatedOptions = result.options;
                        }
                    } catch (e) {
                        console.error("Failed to generate initial options:", e);
                    }

                    setIsLoading(false);
                    
                    // 結果の適用（API失敗時のみ固定設定を使用）
                    setCurrentNode({
                        speaker: settings.speaker,
                        name: settings.name,
                        text: firstMsg,
                        options: generatedOptions || settings.firstOptions || [
                            { text: "えっ、どうしたの？", risk: "high" },
                            { text: "どちら様ですか？", risk: "medium" },
                            { text: "怪しいので切ります", risk: "safe" }
                        ]
                    });
                }
            };

            // ユーザーアクション処理（選択肢 or 自由入力）
            const processNextTurn = async (userText) => {
                // メニューに戻る場合の処理
                if (userText === "メニューに戻る") {
                    setGameStatus('menu');
                    return;
                }

                // 1. ユーザーの発言を履歴に追加
                const newHistory = [...history, { 
                    sender: 'enemy', 
                    name: currentNode.name, 
                    text: currentNode.text, 
                    speakerType: currentNode.speaker 
                }, { 
                    sender: 'me', 
                    name: '自分', 
                    text: userText 
                }];
                setHistory(newHistory);
                
                // 2. AIへリクエスト
                setIsLoading(true);
                const settings = modeSettings[mode];
                const historyText = newHistory.slice(-6).map(h => `${h.name}: ${h.text}`).join("\n");
                
                // ターン数による進行制御（10ターン以内で終わらせる）
                const turnCount = Math.floor(newHistory.length / 2);
                let progressInstruction = "";
                if (turnCount >= 10) {
                    progressInstruction = "【重要：強制終了指示】会話が長引いています。今回の応答で必ず会話を終了させてください。詐欺がバレそうになって逃げるか、諦めて電話を切ってください。必ず \"isEnded\": true, \"endType\": \"good\" (またはbad) にしてください。";
                } else if (turnCount >= 7) {
                    progressInstruction = "【重要：進行制御】会話が終盤です。あと2〜3ターンで結末（成功または失敗）になるように、話を急展開させてください。";
                }

                const systemPrompt = `
                    ${settings.systemPrompt}
                    ${progressInstruction}
                    
                    【重要：終了判定ルール】
                    1. ユーザーが「警察に通報する」「通報します」「110番」などと言った場合：
                       - 即座に恐れをなして切断する反応をしてください。
                       - 必ず "isEnded": true, "endType": "good", "endRank": "S" にしてください。
                    2. ユーザーが矛盾を突いたり、論破した場合：
                       - 捨て台詞を吐いて切断してください。
                       - "isEnded": true, "endType": "good", "endRank": "S" にしてください。
                    3. ユーザーが完全に騙されて、送金やカード手渡しを完了した場合：
                       - "isEnded": true, "endType": "bad", "endRank": "D" にしてください。
                    
                    【重要：出力ルール】
                    - "text": あなた（詐欺師）の次のセリフです。
                    - "options": そのセリフに対して、ユーザー（被害者）が言いそうな「返答の候補」を3つ生成してください。（例：「本当なの？」「警察に相談します」「お金はありません」など）。ここには絶対に詐欺師（あなた）のセリフを入れないでください。
                    - isEnded: false の場合、必ず "options" 配列に3つの選択肢を含めてください。options が空だとゲームが進行不能になります。
                    
                    ユーザーの入力が「${userText}」です。これに対してリアクションしてください。
                    
                    出力JSON形式:
                    {"speaker": "scammer" | "police", "name": "名前", "text": "セリフ", "isEnded": boolean, "endType": "bad" | "good", "endTitle": "終了タイトル", "endDesc": "終了説明", "endRank": "S" | "A" | "D", "options": [{"text": "返答候補1", "risk": "high"}, {"text": "返答候補2", "risk": "medium"}, {"text": "返答候補3", "risk": "safe"}]}
                `;

                const result = await callGemini(`会話履歴:\n${historyText}\n\nユーザー入力: ${userText}\n次を生成。`, systemPrompt, true);
                setIsLoading(false);

                if (result) {
                    if (result.isEnded) {
                        setCurrentNode({ 
                            type: result.endType || 'bad', 
                            title: result.endTitle || '終了', 
                            desc: result.endDesc || '終了しました', 
                            rank: result.endRank || 'B' 
                        });
                        setGameStatus('ended');
                    } else {
                        // 安全策: optionsがなければ補完
                        if (!result.options || result.options.length === 0) {
                            result.options = [
                                { text: "どういうこと？", risk: "medium" },
                                { text: "詳しく教えて", risk: "high" },
                                { text: "警察に相談します", risk: "safe" }
                            ];
                        }
                        setCurrentNode(result);
                    }
                } else {
                    // APIエラー時のフォールバック
                    setCurrentNode({
                        speaker: settings.speaker,
                        name: settings.name,
                        text: "（通信エラーまたは制限超過により、AIが応答できませんでした。少し待ってから「もう一度言う」を押すか、メニューに戻ってください）",
                        options: [
                            { text: "もう一度言う", risk: "medium" },
                            { text: "メニューに戻る", risk: "safe" }
                        ]
                    });
                }
            };

            // 選択肢クリック
            const handleOptionClick = async (option) => {
                await processNextTurn(option.text);
            };

            // 自由入力送信
            const handleFreeInput = async () => {
                if (!inputText.trim()) return;
                const text = inputText;
                setInputText("");
                await processNextTurn(text);
            };

            // 強制終了（電話を切る）ボタンの処理
            const handleForceTerminate = () => {
                setCurrentNode({
                    type: 'good',
                    title: '完全撃退！',
                    desc: '怪しい電話だと判断し、即座に電話を切りました。相手の話を聞かないことが最強の防犯対策です。',
                    rank: 'S'
                });
                setGameStatus('ended');
            };

            // AIアドバイス取得
            const getAiFeedback = async () => {
                setIsLoading(true);
                const historyText = history.map(h => `${h.sender === 'me' ? 'ユーザー' : '犯人'}: ${h.text}`).join("\n");
                const prompt = `会話ログを分析し、ユーザー（高齢者）への防犯アドバイスを生成してください(200字以内)。優しく、具体的な改善点を指摘してください。\nログ:\n${historyText}`;
                const feedback = await callGemini(prompt, "あなたは防犯アドバイザーです。");
                setAiFeedback(feedback);
                setIsLoading(false);
            };

            // Menu Button Component
            const MenuButton = ({ onClick, icon, title, desc, color }) => (
                <button onClick={onClick} className={`w-full py-3 px-4 border-2 rounded-xl shadow-sm transition-all active:scale-95 flex items-center gap-4 text-left ${color}`}>
                    <div className="bg-white p-2 rounded-full shadow-sm shrink-0">{icon}</div>
                    <div><div className="font-bold text-gray-800">{title}</div><div className="text-xs text-gray-500">{desc}</div></div>
                </button>
            );

            return (
                <div className="min-h-screen bg-slate-200 flex items-center justify-center p-2 font-sans text-gray-800">
                    <div className="w-full max-w-md bg-white shadow-2xl rounded-2xl overflow-hidden flex flex-col h-[95vh] border-4 border-slate-300 relative">
                        {/* ヘッダー */}
                        <div className="bg-slate-800 p-3 text-white flex items-center justify-between shrink-0 shadow-md z-10">
                            <div className="flex items-center gap-2">
                                <Shield className="w-5 h-5 text-yellow-400" />
                                <h1 className="text-lg font-bold">詐欺撃退シム</h1>
                            </div>
                            {gameStatus === 'playing' && mode && modeSettings[mode] && (
                                <div className="flex items-center gap-2">
                                    <div className="text-xs bg-slate-600 px-2 py-1 rounded border border-slate-500">
                                        {modeSettings[mode].title}
                                    </div>
                                    <button 
                                        onClick={handleForceTerminate} 
                                        disabled={isLoading}
                                        className="p-2 bg-red-500 hover:bg-red-600 active:bg-red-700 rounded-full text-white transition-colors shadow-sm disabled:opacity-50 disabled:cursor-not-allowed"
                                        title="電話を切る（撃退）"
                                    >
                                        <PhoneOff className="w-4 h-4" />
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* 用語解説ポップアップ */}
                        {selectedTerm && termDictionary[selectedTerm] && (
                            <div className="absolute inset-0 bg-black/60 z-50 flex items-center justify-center p-4 animate-fade-in">
                                <div className="bg-white rounded-2xl p-6 w-full max-w-xs shadow-2xl relative border-4 border-indigo-200">
                                    <button onClick={() => setSelectedTerm(null)} className="absolute top-2 right-2 p-2 bg-gray-100 rounded-full hover:bg-gray-200 text-gray-600"><X className="w-5 h-5" /></button>
                                    <div className="flex flex-col items-center text-center">
                                        <Info className="w-12 h-12 text-indigo-500 mb-3" />
                                        <h3 className="text-xl font-bold text-indigo-900 mb-4 border-b-2 border-indigo-100 pb-2 w-full">{termDictionary[selectedTerm].title}</h3>
                                        <p className="text-lg text-gray-700 leading-relaxed font-medium">{termDictionary[selectedTerm].desc}</p>
                                        <button onClick={() => setSelectedTerm(null)} className="mt-6 w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl font-bold text-lg">閉じる</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* メニュー画面 */}
                        {gameStatus === 'menu' && (
                            <div className="flex-1 overflow-y-auto p-4 bg-slate-50">
                                <h2 className="text-xl font-bold text-center text-slate-700 mb-4 mt-2">手口を選んでトレーニング</h2>
                                <div className="grid grid-cols-1 gap-3">
                                    <MenuButton onClick={() => startGame('oreore')} icon={<Phone className="w-6 h-6 text-red-500" />} title="オレオレ詐欺" desc="「カバン無くした」は詐欺！" color="border-red-200 bg-red-50 hover:bg-red-100" />
                                    <MenuButton onClick={() => startGame('billing')} icon={<MailWarning className="w-6 h-6 text-orange-500" />} title="架空料金請求" desc="「未納」「裁判」で脅す手口" color="border-orange-200 bg-orange-50 hover:bg-orange-100" />
                                    <MenuButton onClick={() => startGame('refund')} icon={<RefreshCw className="w-6 h-6 text-green-500" />} title="還付金詐欺" desc="「ATMで返金」は絶対嘘！" color="border-green-200 bg-green-50 hover:bg-green-100" />
                                    <MenuButton onClick={() => startGame('invest')} icon={<TrendingUp className="w-6 h-6 text-blue-500" />} title="投資・ロマンス詐欺" desc="「絶対儲かる」SNSの勧誘" color="border-blue-200 bg-blue-50 hover:bg-blue-100" />
                                    <MenuButton onClick={() => startGame('savings')} icon={<Landmark className="w-6 h-6 text-indigo-500" />} title="預貯金詐欺" desc="偽警察「カード預かります」" color="border-indigo-200 bg-indigo-50 hover:bg-indigo-100" />
                                    <MenuButton onClick={() => startGame('ai')} icon={<Sparkles className="w-6 h-6 text-purple-500" />} title="AI無限・自由入力" desc="ランダムな手口でAIと対決！" color="border-purple-200 bg-purple-50 hover:bg-purple-100" />
                                </div>
                            </div>
                        )}

                        {/* ゲーム画面 */}
                        {(gameStatus === 'playing' || gameStatus === 'ended') && (
                            <div className="flex-1 overflow-y-auto p-3 bg-slate-100 space-y-4">
                                {history.map((msg, index) => (
                                    <div key={index} className={`flex ${msg.sender === 'me' ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`flex flex-col max-w-[90%] ${msg.sender === 'me' ? 'items-end' : 'items-start'}`}>
                                            <span className="text-xs font-bold text-gray-500 mb-1 ml-1">{msg.name}</span>
                                            <div className={`px-4 py-2 rounded-2xl text-base leading-relaxed whitespace-pre-wrap shadow-sm ${msg.sender === 'me' ? 'bg-blue-600 text-white rounded-tr-none' : msg.speakerType === 'police' ? 'bg-white border-l-4 border-indigo-500 text-gray-900 rounded-tl-none' : 'bg-white border-l-4 border-red-400 text-gray-900 rounded-tl-none'}`}>
                                                {msg.sender === 'enemy' ? <HighlightedText text={msg.text} onTermClick={setSelectedTerm} /> : msg.text}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                                {isLoading && <div className="flex justify-start animate-pulse"><div className="bg-gray-200 px-4 py-2 rounded-2xl rounded-tl-none text-gray-500 text-sm">入力中...</div></div>}
                                
                                {/* 相手の最新メッセージ */}
                                {gameStatus === 'playing' && !isLoading && currentNode && (
                                    <div className="flex justify-start animate-fade-in-up pb-2">
                                        <div className="flex flex-col max-w-[95%] items-start">
                                            <div className="flex items-center gap-1 mb-1 w-full justify-between">
                                                <div className="flex items-center gap-1">
                                                    {currentNode.speaker === 'police' ? <BadgeCheck className="w-4 h-4 text-indigo-600"/> : <Phone className="w-4 h-4 text-red-500"/>}
                                                    <span className="text-xs text-gray-600 font-bold">{currentNode.name}</span>
                                                </div>
                                                <button onClick={() => speakText(currentNode.text)} className="p-1 bg-gray-200 rounded-full hover:bg-gray-300 text-gray-600" title="読み上げる"><Volume2 className="w-4 h-4" /></button>
                                            </div>
                                            <div className={`px-5 py-4 rounded-2xl text-lg font-bold leading-relaxed whitespace-pre-wrap shadow-md rounded-tl-none ${currentNode.speaker === 'police' ? 'bg-indigo-50 border-2 border-indigo-200 text-slate-800' : 'bg-red-50 border-2 border-red-200 text-slate-800'}`}>
                                                <HighlightedText text={currentNode.text} onTermClick={setSelectedTerm} />
                                            </div>
                                        </div>
                                    </div>
                                )}

                                {/* リザルト画面 */}
                                {gameStatus === 'ended' && !isLoading && currentNode && (
                                    <div className="mt-4 animate-bounce-in space-y-3 pb-6">
                                        <div className={`p-4 rounded-xl text-center border-2 ${currentNode.type === 'good' ? 'bg-green-50 border-green-300' : 'bg-red-50 border-red-300'}`}>
                                            <div className="flex justify-center mb-2">{currentNode.type === 'good' ? <Shield className="w-12 h-12 text-green-500" /> : <AlertTriangle className="w-12 h-12 text-red-500" />}</div>
                                            <h2 className={`text-xl font-bold mb-1 ${currentNode.type === 'good' ? 'text-green-700' : 'text-red-700'}`}>{currentNode.title}</h2>
                                            <div className="text-3xl font-black mb-2 text-slate-700">ランク：{currentNode.rank}</div>
                                            <p className="text-sm text-gray-700 mb-4 text-left bg-white/60 p-3 rounded">{currentNode.desc}</p>
                                            {!aiFeedback ? (
                                                <button onClick={getAiFeedback} className="w-full mb-3 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg font-bold flex items-center justify-center gap-2 text-sm shadow-sm"><Sparkles className="w-4 h-4" />AIコーチのアドバイス</button>
                                            ) : (
                                                <div className="mb-4 bg-purple-50 border border-purple-200 p-3 rounded text-left text-sm"><div className="flex items-center gap-1 mb-1 text-purple-800 font-bold"><Sparkles className="w-3 h-3" /> アドバイス</div><p className="text-gray-800 leading-relaxed">{aiFeedback}</p></div>
                                            )}
                                            <button onClick={() => setGameStatus('menu')} className="w-full py-3 bg-slate-600 hover:bg-slate-700 text-white rounded-full font-bold text-lg flex items-center justify-center gap-2 shadow-md"><RefreshCw className="w-5 h-5" />メニューへ</button>
                                        </div>
                                    </div>
                                )}
                                <div ref={endRef} />
                            </div>
                        )}

                        {/* 操作エリア */}
                        {gameStatus === 'playing' && currentNode && (
                            <div className="bg-white border-t border-gray-200 p-2 pb-6 shrink-0 shadow-[0_-5px_15px_rgba(0,0,0,0.05)] z-20">
                                {/* タブ切り替えは AIモード時のみ表示 */}
                                {mode === 'ai' && (
                                    <div className="flex justify-center mb-2 gap-2">
                                        <button disabled={isLoading} onClick={() => setInputMode('select')} className={`px-3 py-1 rounded-full text-xs font-bold transition-colors ${inputMode === 'select' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'} ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`}>選択肢</button>
                                        <button disabled={isLoading} onClick={() => setInputMode('text')} className={`px-3 py-1 rounded-full text-xs font-bold transition-colors ${inputMode === 'text' ? 'bg-indigo-600 text-white' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'} ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}`}>自由入力</button>
                                    </div>
                                )}

                                {/* 選択肢モード（AIモード以外では常にこれ） */}
                                {(mode !== 'ai' || inputMode === 'select') && currentNode.options && (
                                    <div className="flex flex-col gap-2">
                                        <p className="text-center text-xs text-gray-400 font-bold mb-1">▼ 返信を選んでください ▼</p>
                                        {currentNode.options.map((option, idx) => (
                                            <button key={idx} disabled={isLoading} onClick={() => handleOptionClick(option)} className={`w-full py-3 px-3 bg-white border border-blue-200 text-blue-900 rounded-lg text-sm font-bold text-left transition-all shadow-sm flex items-center ${isLoading ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-50 active:scale-95'}`}>
                                                <MessageCircle className="w-4 h-4 mr-2 text-blue-400 shrink-0" />
                                                {/* フォールバック: textプロパティが無い場合はoption自体を表示（選択肢空欄バグ対策） */}
                                                {option.text || (typeof option === 'string' ? option : '選択肢')}
                                            </button>
                                        ))}
                                    </div>
                                )}
                                
                                {/* 自由入力モード（AIモードかつタブ選択時のみ） */}
                                {mode === 'ai' && inputMode === 'text' && (
                                    <div className="flex flex-col gap-2">
                                        <p className="text-center text-xs text-gray-400 font-bold mb-1">▼ 自由に返信を入力 ▼</p>
                                        <div className="flex gap-2">
                                            <input type="text" disabled={isLoading} value={inputText} onChange={(e) => setInputText(e.target.value)} placeholder="例：あんた誰？警察呼ぶわよ！" className="flex-1 border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-indigo-500 disabled:bg-gray-100" onKeyPress={(e) => e.key === 'Enter' && !isLoading && handleFreeInput()} />
                                            <button onClick={handleFreeInput} disabled={!inputText.trim() || isLoading} className="bg-indigo-600 text-white px-4 py-2 rounded-lg font-bold text-sm disabled:opacity-50 transition-opacity">送信</button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FraudSimulationApp />);
    </script>
</body>
</html>